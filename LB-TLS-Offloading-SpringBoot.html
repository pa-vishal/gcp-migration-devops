<h1>
<p>When level 4 / network load balancer is used, it offload TLS. If the backend application is a java spring boot application , how it behaves in these two cases- when TLS offloading happens as a result of use of level 4 load balancer and when not used? For example, does it automatically knows whether TLS offloading has happened  vs not happened?</p>
</h1>
<p>Excellent question. This gets to the heart of how modern web applications interact with infrastructure, and it&#39;s a critical concept for any backend developer to understand.</p>
<p>The short answer is: No, the Spring Boot application does not automatically know.</p>
<p>It&#39;s completely unaware of the original client connection by default. You must explicitly configure it to be aware of the offloading. How it behaves in these two scenarios is fundamentally different, both in terms of configuration and runtime behavior.</p>
<p>Let&#39;s break it down.</p>
<p>Terminology Clarification: L4 Load Balancer</p>
<p>While you said &quot;Level 4,&quot; a load balancer that terminates TLS is technically operating at Level 7 (Application Layer) for that specific function, even if its primary routing logic is L4 (TCP/IP). It has to decrypt the HTTPS packet to see the data, which is an L7 operation. It then forwards the decrypted traffic. This is a very common setup (e.g., AWS Network Load Balancer can do this).</p>
<p>Let&#39;s analyze the two distinct cases.</p>
<p>Case 1: TLS Offloading is Used (Standard Architecture)</p>
<p>In this scenario, the load balancer decrypts the incoming HTTPS traffic and sends it to your Spring Boot application as plain, unencrypted HTTP.</p>
<p>The Flow:
Client --(HTTPS)--&gt; Load Balancer --(HTTP)--&gt; Spring Boot App (on port 8080)</p>
<p>How the Spring Boot Application Sees It:</p>
<p>From the perspective of the embedded server (e.g., Tomcat), it receives a plain HTTP request on port 8080.</p>
<p>If you call request.getScheme(), it will return http.</p>
<p>If you call request.isSecure(), it will return false.</p>
<p>If you call request.getServerPort(), it will return 8080.</p>
<p>The Problem This Creates:
If your application needs to generate an absolute URL (for a redirect, an API response with HATEOAS links, or an email link), it will generate an incorrect URL like <a href="http://yourapi.com:8080/some/path">http://yourapi.com:8080/some/path</a>, which is wrong and will fail.</p>
<p>The Solution: Forwarded Headers
To solve this, the load balancer adds special HTTP headers to the request it sends to your application. These headers tell the backend about the original client request.</p>
<p>The most common headers are:</p>
<p>X-Forwarded-Proto: The original protocol (https in this case).</p>
<p>X-Forwarded-Host: The original host the client connected to (yourapi.com).</p>
<p>X-Forwarded-Port: The original port (443).</p>
<p>X-Forwarded-For: The original client&#39;s IP address.</p>
<p>How to Make Spring Boot &quot;Aware&quot;:
You must configure Spring Boot to look for and trust these headers. You do this in your application.properties or application.yml:</p>
<p>Generated properties</p>
<h1 id="tells-the-embedded-web-server-tomcat-etc-to-look-for-forwarded-headers">Tells the embedded web server (Tomcat, etc.) to look for forwarded headers</h1>
<p>server.forward-headers-strategy=FRAMEWORK</p>
<p>Or, if you are on a specific cloud provider like AWS, you might use NATIVE. FRAMEWORK is the most common for standard X-Forwarded-* headers.</p>
<p>With this configuration:</p>
<p>Spring Boot will now inspect the X-Forwarded-* headers.</p>
<p>When you call request.getScheme(), it will now correctly return https (because it read X-Forwarded-Proto).</p>
<p>request.isSecure() will return true.</p>
<p>Absolute URLs will be generated correctly (e.g., <a href="https://yourapi.com/some/path">https://yourapi.com/some/path</a>).</p>
<p>Case 2: No TLS Offloading (TLS Passthrough)</p>
<p>In this scenario, the L4 load balancer does not decrypt the traffic. It simply forwards the encrypted TCP packets directly to your Spring Boot application on its HTTPS port.</p>
<p>The Flow:
Client --(HTTPS)--&gt; Load Balancer --(Encrypted TCP Passthrough)--&gt; Spring Boot App (on port 8443)</p>
<p>How the Spring Boot Application Sees It:</p>
<p>The embedded server (Tomcat) receives an encrypted TLS connection on port 8443.</p>
<p>It is now fully responsible for the TLS handshake, decrypting the traffic, and processing the request.</p>
<p>How to Make Spring Boot Behave This Way:
Your application must be configured to handle SSL/TLS directly. This involves setting up a keystore with your server&#39;s certificate and private key.</p>
<p>You configure this in your application.properties or application.yml:</p>
<p>Generated properties</p>
<h1 id="the-port-to-listen-on-for-https-traffic">The port to listen on for HTTPS traffic</h1>
<p>server.port=8443</p>
<h1 id="enable-ssl">Enable SSL</h1>
<p>server.ssl.enabled=true</p>
<h1 id="path-to-the-keystore-file-e-g-p12-or-jks-">Path to the keystore file (e.g., .p12 or .jks)</h1>
<p>server.ssl.key-store=classpath:keystore.p12
server.ssl.key-store-password=your-keystore-password
server.ssl.key-store-type=PKCS12
server.ssl.key-alias=your-key-alias
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Properties
IGNORE_WHEN_COPYING_END</p>
<p>With this configuration:</p>
<p>The application directly handles HTTPS.</p>
<p>request.getScheme() will naturally be https, request.isSecure() will be true, and URLs will be generated correctly without needing any forwarded headers.</p>
<p>Summary Table
Feature    Case 1: TLS Offloading    Case 2: No Offloading (Passthrough)
Connection to App    Plain HTTP (e.g., on 8080)    Encrypted HTTPS (e.g., on 8443)
Who Manages Certs?    Load Balancer (Centralized)    Each Spring Boot Instance (Decentralized)
Spring Boot Config    server.forward-headers-strategy=FRAMEWORK    server.ssl.enabled=true and keystore properties.
Key Mechanism    Trusts X-Forwarded-* headers.    Directly handles TLS handshake.
Pros    Standard practice. Centralized cert management, less CPU load on app servers, simplified app config.    Simpler infrastructure (LB is dumber), end-to-end encryption to the pod/instance level.
Cons    Traffic is unencrypted between LB and app. Requires careful network security (e.g., VPC).    Complex certificate management (must deploy certs to all app instances), higher app CPU load.</p>
<p>Conclusion: For most modern, scalable applications, Case 1 (TLS Offloading) is the standard and recommended approach. It simplifies application logic and centralizes the complex and critical task of certificate management at the infrastructure level.</p>
